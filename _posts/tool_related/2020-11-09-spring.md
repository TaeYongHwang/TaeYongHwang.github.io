---
title: "Spring (JAVA framework)"
date: 2020-11-09
toc: true
toc_sticky: true
categories: Tool
---
# 20.11.09 시작

# Spring
- 자바 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량급 애플리케이션 __프레임워크__

## 디자인 패턴

### Adapter Pattern (어댑터 패턴)
- __호출당하는 쪽의 메서드를 호출하는 쪽의 코드에 대응하도록 중간에 변환기를 통해 호출하는 패턴__
- OCP 활용한 설계 패턴
- 같이 쓸 수 없는 클래스를 연결해 사용할 수 있게 해준다.

### Proxy Pattern (프록시 패턴)
- __제어 흐름을 조정하기 위한 목적으로 중간에 대리자를 두는 패턴__
- OCP, DIP 활용한 설계 패턴 
- 프록시에서 실제 서비스와 같은 이름의 메서드를 구현 (인터페이스 사용)
- 프록시는 실제 서비스에 대한 참조 변수를 갖는다.
- 프록시에서 실제 서비스에 존재하는 같은 이름의 메서드를 호출한 후 해당 값을 반환한다 (전후에 추가 로직 수행 가능)
- 반환값에 대한 변경은 최대한 이루어지지 않게

### Decorator Pattern (데코레이터 패턴)
- __메서드 호출의 반환값에 변화를 주기 위해 중간에 데코레이터를 두는 패턴__
- 프록시 패턴과 구현 방식은 동일하지만, 반환값에 대한 변경이 일어난다.
- OCP, DIP 활용한 설계 패턴

### Singleton Pattern (싱글턴 패턴)
- __클래스에 대한 인스턴스를 오직 하나만 만들어 사용하기 위한 패턴__ (불필요한 자원 낭비 최소화)
- new를 실행할 수 없도록 생성자에 private 접근 제어자를 지정한다. (객체를 생성하는 과정을 없앰)
- 유일한 객체를 반환할 수 있는 static 메서드가 필요
- 유일한 객체를 참조할 static 변수가 필요
- read only 변수만 존재하게 설계해야 한다.

### Template Method Pattern (템플릿 메서드 패턴)
- __상위 클래스의 템플릿 메서드에서 하위 클래스가 오버라이딩한 메서드를 호출하는 패턴__
- DIP 활용한 설계 패턴
- 전체적으로는 동일하면서 부분적으로 다른 메서드의 코드 중복을 최소화시킴
- 오버라이딩을 강제하는 부분과 그렇지 않은 부분으로 나눠서 관리한다.


### Factory Method Pattern (팩토리 메서드 패턴)
- Factory : 객체를 생성해 반환하는 메서드
- __오버라이드된 메서드가 객체를 반환하는 패턴__
- DIP 활용한 설계 패턴


### Strategy Pattern (전략 패턴)
- strategy, context, client 의 세 요소로 구성
- __client에서 strategy 객체를생성해 context에 주입하는 패턴__
- 자바에서는 단일 상속만 지원하기 때문에, 템플릿 메서드 패턴보다 전략 패턴을 많이 사용한다.
- OCP, DIP 활용한 설계 패턴

#### Template Callback Pattern (견본/회신 패턴)
- DI (의존성 주입)에서 사용하는 특별한 형태의 전략 패턴
- 전략 패턴과 동일하지만, strategy를 __anonymous inner class__로 정의해서 사용한다
- OCP, DIP 활용한 설계 패턴

### MVC 패턴 (Model - View - Controller)
- Model : 백그라운드 동작 로직 처리
- View : 사용자가 볼 결과 화면 출력
- Controller : Model - View 를 연결해주는 역할 


## 스프링 삼각형
- POJO(Plain Old Java Object) 를 기반으로 하는 __IOC/DI, AOP, PSA__ 의 3대 프로그래밍 모델

### IOC/DI
- __Inversion Of Control / Dependency Injection, 제어의 역전/ 의존성 주입__


#### Bean
- Spring IoC Container가 관리하는 자바 객체를 __빈(bean)__ 이라고 한다.
```
import org.springframework.context.ApplicationContext;
// ApplicationContext 에서 getBean 메서드를 이용해 받아올 수 있는 객체를 빈이라고 한다.
// new 로 생성하는 경우 빈이 아니다

---------------------------------------

import org.springframework.beans.factory.annotation.Autowired;

// type (인터페이스) 기준 매칭 - 여러개의 클래스가 존재하는 경우 빈 태그의 id로 구분
// 유니크하게 식별이 불가능할 경우 에러
@Autowired  
Tire tire; //스프링 프레임워크가 설정 파일을 통해 대신 주입해준다.

--------------------------------------

import javax.annotation.Resuorce;

// 자바 표준 어노테이션
// id 기준 매칭 - id에 맞는 빈이 없는 경우 type으로 찾는다.
@Resource
Tire tire;

```

### AOP (Aspect Oriented Programming)
- 로직(code)에 대한 주입 - 메서드에만 적용 가능
- cross-cutting concern (횡단 관심사) : 다수의 모듈에 공통으로 나타나는 부분
- 코드 주입 가능한 부분 : Around, Before, After, AfterReturning, AfterThrowing
- __인터페이스, 프록시, 런타임__ 기반

- PointCut : 삽입 지점을 명시 
> 형태   
> [접근제한자] 리턴타입 [패키지&클래스패턴].메서드이름패턴(파리미터패턴) [throws 예외패턴]

- JoinPoint : 호출된 객체의 메서드

```
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

@Aspect // MyAspect 클래스를 AOP에서 사용하겠다는 의미
public class MyAspect {
    //apo002.Boy.runSomething 실행 전에 해당 메서드를 실행한다.
	@Before("execution(public void aop002.Boy.runSomething ())") // excution 내부가 PointCut
	public void before(JoinPoint joinPoint) {
		System.out.println("...");
	}
}

```

### PSA (Portable Service Abstraction)
- 일관성 있는 서비스 추상화
- ORM, ... 등등 일관된 방식으로 코드를 작성할 수 있게 해준다



  

## Maven




























   
> 출처   
> 스프링 입문을 위한 자바 객체지향의 원리와 이해









